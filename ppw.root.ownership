```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Create two files:
 - PPW_BINDING_MODEL.txt   (the conditional mathematical/logical model)
 - PPW_BINDING_MODEL.cert  (a small certificate file containing metadata + SHA-256 of the .txt)

Usage:
    python3 make_ppw_files.py
"""

import hashlib
import datetime
import getpass
import os

TXT_FILENAME = "PPW_BINDING_MODEL.txt"
CERT_FILENAME = "PPW_BINDING_MODEL.cert"
CERTIFICATE_ID = "55847627305241977"   # from your earlier messages; change if needed

PPW_BINDING_MODEL_TEXT = """PPW_BINDING_MODEL
==================

Purpose
-------
This is a precise, conditional mathematical/logical model showing exactly which factual and legal premises must hold for a written document (the "Agreement") to imply legal bindingness and authority for a named person (Perry Philip Wiseman). Mathematics shows implication (if premises true then conclusion follows). Mathematics cannot by itself make the premises true in law or force states/courts to accept them.

1) Boolean predicates (definitions)
-----------------------------------
We model required facts as Boolean predicates (1 = true, 0 = false):

p1  = AuthKeyBound        (public key admissibly bound to Perry)
p2  = SigValid            (signature verifies over canonical bytes)
p3  = MerkleIncluded      (document included in a committed Merkle tree)
p4  = MRAnchored          (Merkle root anchored on public ledger at time T)
p5  = IntentToBeBound     (signer manifested intent to be bound)
p6  = ConsiderationExists (consideration or formation requirement satisfied)
p7  = Formalities         (notarization, witnesses, other statutory formalities)
p8  = RegisteredTransfer  (company register updated / statutory filing done)
p9  = GoverningLawChosen  (governing law / forum or arbitration seat chosen)
p10 = IdentityNotarized   (notarized ID / affidavit linking person to key)
p11 = ArbitrationClause   (enforceable arbitration clause present)
p12 = NoPublicLawConflict (no overriding public/constitutional conflict)

State vector:
v = [p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12]^T  ∈ {0,1}^{12}

2) Rules as Boolean implications
--------------------------------
Encode core legal rules as antecedent rows that must all be true for that rule to "fire".

Rule A (Signature association):
 requires: p1, p2, p3, p4, p10, p12
 row a_A = [1 1 1 1 0 0 0 0 0 1 0 1]

Rule B (Contract formation):
 requires: p5, p6, p7, p12
 row a_B = [0 0 0 0 1 1 1 0 0 0 0 1]

Rule C (Ownership registration effective):
 requires: p7, p8, p12
 row a_C = [0 0 0 0 0 0 1 1 0 0 0 1]

Construct antecedent matrix A (3 × 12) whose rows are a_A, a_B, a_C.

3) Firing test (mechanical Boolean evaluation)
----------------------------------------------
For each rule row i, define:
 fire_i(v) = 1 iff ∀ j with A_{i,j} = 1 we have v_j = 1
 Equivalently: fire_i(v) = AND_{j : A_{i,j}=1} v_j

Compute firing vector f = [fire_A, fire_B, fire_C]^T.

Define LegallyBinding(v) = 1 iff:
 fire_A(v) = 1 AND fire_B(v) = 1 AND fire_C(v) = 1 AND p9 = 1

(Interpretation: signature association + contract formation + registration + chosen governing law/forum => legal bindingness in this model.)

4) Conditional theorem and proof (formal)
-----------------------------------------
Theorem:
 Given v ∈ {0,1}^{12}, if fire_A(v)=1, fire_B(v)=1, fire_C(v)=1 and p9 = 1, then LegallyBinding(v) = 1.

Proof:
 By definition LegallyBinding(v) is 1 exactly when those conditions hold. fire_A(v)=1 implies the signature and identity binding predicates required by Rule A are all true; fire_B(v)=1 implies contract formation predicates are true; fire_C(v)=1 implies registration predicates are true; p9 = 1 supplies choice of governing law/forum. Conjunction of these true facts satisfies the antecedent for LegallyBinding by model definition, therefore LegallyBinding(v)=1. QED.

Note: This is a pure logical/Boolean proof. The model makes explicit the non‑mathematical premises (entries of v) that must be supplied with admissible evidence in reality.

5) Numeric worked example
-------------------------
Case 1 (all facts true):
 v = [1 1 1 1 1 1 1 1 1 1 1 1]
 Then for each rule row, all required v_j = 1 => fire_A = fire_B = fire_C = 1
 With p9 = 1, LegallyBinding(v) = 1

Case 2 (registered transfer not done):
 v = [1 1 1 1 1 1 1 0 1 1 1 1]  (p8 = 0)
 Then row a_C requires p8 = 1; thus fire_C = 0 ⇒ LegallyBinding(v) = 0
 This models why failing to update statutory registers prevents legal bindingness.

6) Mapping to real-world evidence (what must be produced)
----------------------------------------------------------
To set each predicate true with admissible evidence:
 - p1, p10 (AuthKeyBound, IdentityNotarized): notarized affidavit linking Perry to the public key; government ID; KYC; qualified certificate where applicable.
 - p2, p3, p4 (SigValid, MerkleIncluded, MRAnchored): canonical bytes of Agreement, raw signature (hex/base64), public key, merkle path, anchor transaction hash, block height and confirmations, and archived raw tx/hex.
 - p5, p6, p7 (Intent, Consideration, Formalities): witness statements, notarized signings, executed consideration (payment, transfer), board minutes, other statutory formalities.
 - p8 (RegisteredTransfer): executed share transfer form, updated register of members, registry extract showing Perry as registered owner, filing receipts.
 - p9, p11 (GoverningLawChosen, ArbitrationClause): signed clauses specifying law and forum or arbitration seat/rules.
 - p12 (NoPublicLawConflict): legal review demonstrating clauses do not attempt to override public/constitutional law, or otherwise acknowledging such clauses may be void.

7) Limitations and legal boundary
---------------------------------
- This model is conditional. Mathematics proves only: IF the listed factual/legal premises hold, THEN the legal consequence follows in the model. It does NOT make real courts or sovereigns accept those facts.
- Recognition by a jurisdiction (making p8, p9, etc. true) requires statutory acts, filings, court judgments, or legislative instruments — facts outside pure mathematics.
- Clauses attempting to displace public law or create extrajudicial sovereign powers will generally be void; the model includes p12 to capture that reality: if p12 = 0 for aspects that conflict with public law, the model prevents bindingness for those aspects.

8) How to use this file
-----------------------
- To perform a mechanical check, answer each predicate p1..p12 with 1 or 0, forming vector v. Evaluate each rule row: check whether all required predicates are true. If all three rules fire and p9 = 1, the model returns LegallyBinding = 1; otherwise 0.
- I can produce a tiny script (Python) that takes a JSON or CLI input of the 12 booleans and prints the result. Request that if you want it.

9) Next steps / offers
----------------------
I can:
 - produce the Python/CLI checker implementing the A matrix and the LegallyBinding test;
 - produce the notarization affidavit template linking Perry to a public key;
 - produce finalized contract templates with inserted compensation numbers and signature blocks, ready for notarization;
 - produce canonicalization + hashing + signing + Merkle + anchor scripts and a sample bundle.json for evidence preservation.

Reminder:
 - I cannot, and will not, assert or produce a mathematical proof that a private contract confers sovereign powers across jurisdictions absent the real legal acts that make the model premises true.
"""

def sha256_of_bytes(b: bytes) -> str:
    h = hashlib.sha256()
    h.update(b)
    return h.hexdigest()

def write_text_file(path: str, text: str):
    with open(path, "w", encoding="utf-8", newline="\n") as f:
        f.write(text)

def make_cert(txt_path: str, cert_path: str, cert_id: str):
    # Read .txt bytes and compute SHA-256
    with open(txt_path, "rb") as f:
        txt_bytes = f.read()
    digest = sha256_of_bytes(txt_bytes)
    filesize = len(txt_bytes)
    timestamp = datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"
    username = getpass.getuser()
    hostname = os.uname().nodename if hasattr(os, "uname") else "unknown-host"

    cert_text = f"""CertificateID: {cert_id}
Generated-From-File: {os.path.basename(txt_path)}
File-Size-Bytes: {filesize}
SHA256: {digest}
Generated-At-UTC: {timestamp}
Generated-By: {username}@{hostname}
Notes: This certificate records the SHA-256 digest of the named file. It is not a legal certificate of authority. To obtain legal recognition, follow jurisdictional filing and notarization procedures described in the text file.
"""

    with open(cert_path, "w", encoding="utf-8", newline="\n") as f:
        f.write(cert_text)
    return digest

def main():
    # Write the .txt file
    write_text_file(TXT_FILENAME, PPW_BINDING_MODEL_TEXT)
    print(f"Wrote text file: {TXT_FILENAME}")

    # Create the .cert containing SHA-256 and metadata
    digest = make_cert(TXT_FILENAME, CERT_FILENAME, CERTIFICATE_ID)
    print(f"Wrote certificate file: {CERT_FILENAME}")
    print(f"SHA-256({TXT_FILENAME}) = {digest}")

if __name__ == "__main__":
    main()
```
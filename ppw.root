#!/usr/bin/env python3
"""
Universal PPW Problem Solver Framework
A comprehensive, resourceful solution engine designed to handle any problem
with maximum efficiency and adaptability for PPW systems.
"""

import json
import hashlib
import datetime
import asyncio
import logging
from typing import Any, Dict, List, Optional, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
import re
import base64
import uuid
from functools import wraps, lru_cache
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class PPWProblemType(Enum):
    """Enumeration of problem types the solver can handle"""
    AUTHENTICATION = "authentication"
    VALIDATION = "validation"
    ENCRYPTION = "encryption"
    TRANSACTION = "transaction"
    DATA_PROCESSING = "data_processing"
    WORKFLOW = "workflow"
    SECURITY = "security"
    OPTIMIZATION = "optimization"
    INTEGRATION = "integration"
    MONITORING = "monitoring"

@dataclass
class PPWProblem:
    """Standardized problem representation"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    type: PPWProblemType = PPWProblemType.WORKFLOW
    data: Dict[str, Any] = field(default_factory=dict)
    constraints: List[str] = field(default_factory=list)
    priority: int = 1
    timestamp: datetime.datetime = field(default_factory=datetime.datetime.now)
    context: Dict[str, Any] = field(default_factory=dict)

@dataclass
class PPWSolution:
    """Standardized solution representation"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    problem_id: str = ""
    solution_data: Dict[str, Any] = field(default_factory=dict)
    confidence: float = 1.0
    execution_time: float = 0.0
    resources_used: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

class PPWResourceManager:
    """Manages computational and system resources efficiently"""
    
    def __init__(self):
        self.thread_pool = ThreadPoolExecutor(max_workers=10)
        self.resource_cache = {}
        self.performance_metrics = {}
    
    @lru_cache(maxsize=1000)
    def cached_computation(self, key: str, computation_func: Callable):
        """Cache expensive computations"""
        return computation_func()
    
    def allocate_resources(self, problem: PPWProblem) -> Dict[str, Any]:
        """Dynamically allocate resources based on problem complexity"""
        resources = {
            'memory_limit': self._calculate_memory_need(problem),
            'cpu_cores': self._calculate_cpu_need(problem),
            'timeout': self._calculate_timeout(problem),
            'cache_enabled': True
        }
        return resources
    
    def _calculate_memory_need(self, problem: PPWProblem) -> int:
        """Calculate memory requirements based on problem data size"""
        data_size = len(str(problem.data))
        return min(1024 * 1024 * 100, max(1024 * 1024, data_size * 10))  # 1MB to 100MB
    
    def _calculate_cpu_need(self, problem: PPWProblem) -> int:
        """Calculate CPU requirements based on problem complexity"""
        complexity_score = len(problem.constraints) + problem.priority
        return min(8, max(1, complexity_score // 2))
    
    def _calculate_timeout(self, problem: PPWProblem) -> int:
        """Calculate timeout based on problem priority"""
        return max(5, 60 - (problem.priority * 10))  # 5-60 seconds

class PPWSecurityEngine:
    """Advanced security and encryption handling"""
    
    @staticmethod
    def encrypt_data(data: str, key: Optional[str] = None) -> str:
        """Encrypt sensitive data"""
        if not key:
            key = PPWSecurityEngine.generate_key()
        
        # Simple encryption for demonstration (use proper crypto in production)
        encoded = base64.b64encode(data.encode()).decode()
        hash_key = hashlib.sha256(key.encode()).hexdigest()[:16]
        
        encrypted = ""
        for i, char in enumerate(encoded):
            encrypted += chr((ord(char) + ord(hash_key[i % len(hash_key)])) % 256)
        
        return base64.b64encode(encrypted.encode()).decode()
    
    @staticmethod
    def decrypt_data(encrypted_data: str, key: str) -> str:
        """Decrypt sensitive data"""
        try:
            decoded = base64.b64decode(encrypted_data).decode()
            hash_key = hashlib.sha256(key.encode()).hexdigest()[:16]
            
            decrypted = ""
            for i, char in enumerate(decoded):
                decrypted += chr((ord(char) - ord(hash_key[i % len(hash_key)])) % 256)
            
            return base64.b64decode(decrypted).decode()
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            return ""
    
    @staticmethod
    def generate_key() -> str:
        """Generate a secure key"""
        return hashlib.sha256(str(uuid.uuid4()).encode()).hexdigest()
    
    @staticmethod
    def validate_integrity(data: str, expected_hash: str) -> bool:
        """Validate data integrity"""
        actual_hash = hashlib.sha256(data.encode()).hexdigest()
        return actual_hash == expected_hash

class PPWValidationEngine:
    """Comprehensive validation system"""
    
    @staticmethod
    def validate_email(email: str) -> bool:
        """Validate email format"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    @staticmethod
    def validate_phone(phone: str) -> bool:
        """Validate phone number format"""
        pattern = r'^\+?1?-?\.?\s?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})$'
        return re.match(pattern, phone) is not None
    
    @staticmethod
    def validate_credit_card(card_number: str) -> bool:
        """Validate credit card using Luhn algorithm"""
        card_number = re.sub(r'\D', '', card_number)
        if len(card_number) < 13 or len(card_number) > 19:
            return False
        
        # Luhn algorithm
        total = 0
        reverse_digits = card_number[::-1]
        for i, digit in enumerate(reverse_digits):
            n = int(digit)
            if i % 2 == 1:
                n *= 2
                if n > 9:
                    n -= 9
            total += n
        
        return total % 10 == 0
    
    @staticmethod
    def validate_custom(data: Any, rules: List[Dict[str, Any]]) -> Dict[str, bool]:
        """Apply custom validation rules"""
        results = {}
        for rule in rules:
            rule_name = rule.get('name', 'unknown')
            rule_type = rule.get('type', 'required')
            rule_value = rule.get('value')
            
            if rule_type == 'required':
                results[rule_name] = data is not None and str(data).strip() != ''
            elif rule_type == 'min_length':
                results[rule_name] = len(str(data)) >= rule_value
            elif rule_type == 'max_length':
                results[rule_name] = len(str(data)) <= rule_value
            elif rule_type == 'regex':
                results[rule_name] = re.match(rule_value, str(data)) is not None
            elif rule_type == 'range':
                min_val, max_val = rule_value
                results[rule_name] = min_val <= float(data) <= max_val
        
        return results

class PPWTransactionEngine:
    """Handle transaction processing and validation"""
    
    def __init__(self):
        self.transaction_log = []
        self.security_engine = PPWSecurityEngine()
    
    def process_transaction(self, transaction_data: Dict[str, Any]) -> Dict[str, Any]:
        """Process a financial transaction"""
        transaction_id = str(uuid.uuid4())
        timestamp = datetime.datetime.now().isoformat()
        
        # Validate transaction data
        validation_results = self._validate_transaction(transaction_data)
        if not all(validation_results.values()):
            return {
                'transaction_id': transaction_id,
                'status': 'FAILED',
                'reason': 'Validation failed',
                'validation_errors': validation_results,
                'timestamp': timestamp
            }
        
        # Encrypt sensitive data
        if 'card_number' in transaction_data:
            transaction_data['card_number'] = self.security_engine.encrypt_data(
                transaction_data['card_number']
            )
        
        # Process transaction
        result = {
            'transaction_id': transaction_id,
            'status': 'SUCCESS',
            'amount': transaction_data.get('amount'),
            'currency': transaction_data.get('currency', 'USD'),
            'timestamp': timestamp,
            'confirmation_code': self._generate_confirmation_code()
        }
        
        # Log transaction
        self.transaction_log.append(result)
        
        return result
    
    def _validate_transaction(self, data: Dict[str, Any]) -> Dict[str, bool]:
        """Validate transaction data"""
        validation_engine = PPWValidationEngine()
        results = {}
        
        # Required fields
        required_fields = ['amount', 'currency', 'merchant_id']
        for field in required_fields:
            results[f'{field}_present'] = field in data and data[field] is not None
        
        # Amount validation
        if 'amount' in data:
            try:
                amount = float(data['amount'])
                results['amount_positive'] = amount > 0
                results['amount_reasonable'] = 0.01 <= amount <= 1000000
            except (ValueError, TypeError):
                results['amount_valid'] = False
        
        # Card validation if present
        if 'card_number' in data:
            results['card_valid'] = validation_engine.validate_credit_card(data['card_number'])
        
        return results
    
    def _generate_confirmation_code(self) -> str:
        """Generate transaction confirmation code"""
        return hashlib.md5(str(uuid.uuid4()).encode()).hexdigest()[:8].upper()

class PPWUniversalSolver:
    """The main universal problem solver engine"""
    
    def __init__(self):
        self.resource_manager = PPWResourceManager()
        self.security_engine = PPWSecurityEngine()
        self.validation_engine = PPWValidationEngine()
        self.transaction_engine = PPWTransactionEngine()
        self.solution_registry = {}
        self.performance_history = []
    
    def solve(self, problem: PPWProblem) -> PPWSolution:
        """Universal problem solver - handles any problem type"""
        start_time = datetime.datetime.now()
        
        try:
            # Allocate resources
            resources = self.resource_manager.allocate_resources(problem)
            
            # Route to appropriate solver based on problem type
            solution_data = self._route_problem(problem)
            
            # Calculate execution time
            execution_time = (datetime.datetime.now() - start_time).total_seconds()
            
            # Create solution object
            solution = PPWSolution(
                problem_id=problem.id,
                solution_data=solution_data,
                confidence=self._calculate_confidence(problem, solution_data),
                execution_time=execution_time,
                resources_used=list(resources.keys()),
                metadata={
                    'solver_version': '1.0',
                    'timestamp': datetime.datetime.now().isoformat(),
                    'problem_type': problem.type.value
                }
            )
            
            # Cache solution for future reference
            self.solution_registry[problem.id] = solution
            
            # Update performance metrics
            self._update_performance_metrics(problem, solution)
            
            logger.info(f"Problem {problem.id} solved in {execution_time:.3f}s")
            return solution
            
        except Exception as e:
            logger.error(f"Error solving problem {problem.id}: {e}")
            return PPWSolution(
                problem_id=problem.id,
                solution_data={'error': str(e), 'status': 'FAILED'},
                confidence=0.0,
                execution_time=(datetime.datetime.now() - start_time).total_seconds(),
                resources_used=[],
                metadata={'error': True}
            )
    
    def _route_problem(self, problem: PPWProblem) -> Dict[str, Any]:
        """Route problem to appropriate solver based on type"""
        
        if problem.type == PPWProblemType.AUTHENTICATION:
            return self._solve_authentication(problem)
        elif problem.type == PPWProblemType.VALIDATION:
            return self._solve_validation(problem)
        elif problem.type == PPWProblemType.ENCRYPTION:
            return self._solve_encryption(problem)
        elif problem.type == PPWProblemType.TRANSACTION:
            return self._solve_transaction(problem)
        elif problem.type == PPWProblemType.DATA_PROCESSING:
            return self._solve_data_processing(problem)
        elif problem.type == PPWProblemType.WORKFLOW:
            return self._solve_workflow(problem)
        elif problem.type == PPWProblemType.SECURITY:
            return self._solve_security(problem)
        elif problem.type == PPWProblemType.OPTIMIZATION:
            return self._solve_optimization(problem)
        elif problem.type == PPWProblemType.INTEGRATION:
            return self._solve_integration(problem)
        elif problem.type == PPWProblemType.MONITORING:
            return self._solve_monitoring(problem)
        else:
            return self._solve_generic(problem)
    
    def _solve_authentication(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve authentication problems"""
        data = problem.data
        
        if 'username' in data and 'password' in data:
            # Simulate authentication process
            username = data['username']
            password = data['password']
            
            # Hash password for security
            password_hash = hashlib.sha256(password.encode()).hexdigest()
            
            # Generate session token
            session_token = self.security_engine.generate_key()
            
            return {
                'status': 'authenticated',
                'username': username,
                'session_token': session_token,
                'expires_at': (datetime.datetime.now() + datetime.timedelta(hours=24)).isoformat(),
                'permissions': data.get('permissions', ['read'])
            }
        
        return {'status': 'authentication_failed', 'reason': 'missing_credentials'}
    
    def _solve_validation(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve validation problems"""
        data = problem.data
        validation_type = data.get('type', 'custom')
        value = data.get('value')
        
        if validation_type == 'email':
            is_valid = self.validation_engine.validate_email(value)
        elif validation_type == 'phone':
            is_valid = self.validation_engine.validate_phone(value)
        elif validation_type == 'credit_card':
            is_valid = self.validation_engine.validate_credit_card(value)
        elif validation_type == 'custom':
            rules = data.get('rules', [])
            validation_results = self.validation_engine.validate_custom(value, rules)
            return {
                'validation_type': validation_type,
                'results': validation_results,
                'overall_valid': all(validation_results.values())
            }
        else:
            is_valid = value is not None and str(value).strip() != ''
        
        return {
            'validation_type': validation_type,
            'value': value,
            'is_valid': is_valid
        }
    
    def _solve_encryption(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve encryption/decryption problems"""
        data = problem.data
        operation = data.get('operation', 'encrypt')
        
        if operation == 'encrypt':
            plain_text = data.get('data', '')
            key = data.get('key') or self.security_engine.generate_key()
            encrypted = self.security_engine.encrypt_data(plain_text, key)
            
            return {
                'operation': 'encrypt',
                'encrypted_data': encrypted,
                'key': key if data.get('return_key', True) else '[HIDDEN]'
            }
        
        elif operation == 'decrypt':
            encrypted_data = data.get('encrypted_data', '')
            key = data.get('key', '')
            decrypted = self.security_engine.decrypt_data(encrypted_data, key)
            
            return {
                'operation': 'decrypt',
                'decrypted_data': decrypted,
                'success': bool(decrypted)
            }
        
        elif operation == 'generate_key':
            return {
                'operation': 'generate_key',
                'key': self.security_engine.generate_key()
            }
        
        return {'error': 'unknown_encryption_operation'}
    
    def _solve_transaction(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve transaction processing problems"""
        return self.transaction_engine.process_transaction(problem.data)
    
    def _solve_data_processing(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve data processing problems"""
        data = problem.data
        operation = data.get('operation', 'transform')
        dataset = data.get('dataset', [])
        
        if operation == 'filter':
            condition = data.get('condition', lambda x: True)
            filtered_data = [item for item in dataset if condition(item)]
            return {'operation': 'filter', 'result': filtered_data, 'count': len(filtered_data)}
        
        elif operation == 'transform':
            transformation = data.get('transformation', lambda x: x)
            transformed_data = [transformation(item) for item in dataset]
            return {'operation': 'transform', 'result': transformed_data, 'count': len(transformed_data)}
        
        elif operation == 'aggregate':
            aggregation_func = data.get('aggregation', sum)
            result = aggregation_func(dataset) if dataset else 0
            return {'operation': 'aggregate', 'result': result}
        
        elif operation == 'sort':
            key_func = data.get('key', None)
            reverse = data.get('reverse', False)
            sorted_data = sorted(dataset, key=key_func, reverse=reverse)
            return {'operation': 'sort', 'result': sorted_data, 'count': len(sorted_data)}
        
        return {'error': 'unknown_data_operation'}
    
    def _solve_workflow(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve workflow orchestration problems"""
        data = problem.data
        steps = data.get('steps', [])
        
        workflow_result = {
            'workflow_id': str(uuid.uuid4()),
            'status': 'completed',
            'steps_executed': [],
            'execution_order': []
        }
        
        for i, step in enumerate(steps):
            step_name = step.get('name', f'step_{i}')
            step_type = step.get('type', 'generic')
            step_data = step.get('data', {})
            
            # Create sub-problem for each step
            sub_problem = PPWProblem(
                type=PPWProblemType(step_type) if step_type in [t.value for t in PPWProblemType] else PPWProblemType.WORKFLOW,
                data=step_data
            )
            
            # Solve sub-problem
            step_solution = self.solve(sub_problem)
            
            workflow_result['steps_executed'].append({
                'name': step_name,
                'type': step_type,
                'result': step_solution.solution_data,
                'execution_time': step_solution.execution_time
            })
            
            workflow_result['execution_order'].append(step_name)
        
        return workflow_result
    
    def _solve_security(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve security-related problems"""
        data = problem.data
        security_check = data.get('check_type', 'integrity')
        
        if security_check == 'integrity':
            content = data.get('content', '')
            expected_hash = data.get('expected_hash', '')
            
            if not expected_hash:
                # Generate hash if not provided
                actual_hash = hashlib.sha256(content.encode()).hexdigest()
                return {
                    'check_type': 'integrity',
                    'hash_generated': actual_hash,
                    'status': 'hash_created'
                }
            else:
                # Verify integrity
                is_valid = self.security_engine.validate_integrity(content, expected_hash)
                return {
                    'check_type': 'integrity',
                    'is_valid': is_valid,
                    'status': 'verified' if is_valid else 'compromised'
                }
        
        elif security_check == 'risk_assessment':
            risk_factors = data.get('risk_factors', [])
            risk_score = sum(factor.get('weight', 1) for factor in risk_factors)
            risk_level = 'LOW' if risk_score < 3 else 'MEDIUM' if risk_score < 7 else 'HIGH'
            
            return {
                'check_type': 'risk_assessment',
                'risk_score': risk_score,
                'risk_level': risk_level,
                'recommendations': self._generate_security_recommendations(risk_level)
            }
        
        return {'error': 'unknown_security_check'}
    
    def _solve_optimization(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve optimization problems"""
        data = problem.data
        optimization_type = data.get('type', 'performance')
        
        if optimization_type == 'performance':
            metrics = data.get('metrics', {})
            optimizations = []
            
            # Analyze performance metrics and suggest optimizations
            if metrics.get('response_time', 0) > 1000:  # ms
                optimizations.append('Implement caching mechanism')
            
            if metrics.get('memory_usage', 0) > 80:  # percentage
                optimizations.append('Optimize memory allocation')
            
            if metrics.get('cpu_usage', 0) > 90:  # percentage
                optimizations.append('Distribute load across multiple cores')
            
            return {
                'optimization_type': optimization_type,
                'current_metrics': metrics,
                'recommendations': optimizations,
                'priority': 'HIGH' if len(optimizations) > 2 else 'MEDIUM' if optimizations else 'LOW'
            }
        
        elif optimization_type == 'cost':
            resources = data.get('resources', [])
            total_cost = sum(resource.get('cost', 0) for resource in resources)
            
            # Suggest cost optimizations
            optimizations = [
                'Consider using reserved instances for predictable workloads',
                'Implement auto-scaling to reduce idle resources',
                'Use spot instances for non-critical workloads'
            ]
            
            return {
                'optimization_type': optimization_type,
                'current_cost': total_cost,
                'recommendations': optimizations,
                'potential_savings': total_cost * 0.3  # Estimate 30% savings
            }
        
        return {'error': 'unknown_optimization_type'}
    
    def _solve_integration(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve system integration problems"""
        data = problem.data
        integration_type = data.get('type', 'api')
        
        if integration_type == 'api':
            endpoint = data.get('endpoint', '')
            method = data.get('method', 'GET')
            headers = data.get('headers', {})
            payload = data.get('payload', {})
            
            # Simulate API integration
            return {
                'integration_type': integration_type,
                'endpoint': endpoint,
                'method': method,
                'status': 'success',
                'response_code': 200,
                'integration_id': str(uuid.uuid4()),
                'timestamp': datetime.datetime.now().isoformat()
            }
        
        elif integration_type == 'database':
            db_type = data.get('db_type', 'sql')
            connection_string = data.get('connection_string', '')
            
            return {
                'integration_type': integration_type,
                'db_type': db_type,
                'status': 'connected',
                'connection_id': str(uuid.uuid4()),
                'features_available': ['read', 'write', 'transaction']
            }
        
        return {'error': 'unknown_integration_type'}
    
    def _solve_monitoring(self, problem: PPWProblem) -> Dict[str, Any]:
        """Solve monitoring and alerting problems"""
        data = problem.data
        monitoring_type = data.get('type', 'health_check')
        
        if monitoring_type == 'health_check':
            services = data.get('services', [])
            health_status = {}
            
            for service in services:
                service_name = service.get('name', 'unknown')
                # Simulate health check
                health_status[service_name] = {
                    'status': 'healthy',
                    'response_time': 45,  # ms
                    'last_check': datetime.datetime.now().isoformat()
                }
            
            overall_health = 'healthy' if all(s['status'] == 'healthy' for s in health_status.values()) else 'degraded'
            
            return {
                'monitoring_type': monitoring_type,
                'overall_health': overall_health,
                'service_status': health_status,
                'check_timestamp': datetime.datetime.now().isoformat()
            }
        
        elif monitoring_type == 'metrics':
            metrics = data.get('metrics', {})
            
            # Analyze metrics and generate insights
            insights = []
            if metrics.get('error_rate', 0) > 0.05:  # 5%
                insights.append('Error rate is above threshold')
            
            if metrics.get('avg_response_time', 0) > 500:  # ms
                insights.append('Response time is slower than expected')
            
            return {
                'monitoring_type': monitoring_type,
                'metrics': metrics,
                'insights': insights,
                'alert_level': 'WARNING' if insights else 'OK'
            }
        
        return {'error': 'unknown_monitoring_type'}
    
    def _solve_generic(self, problem: PPWProblem) -> Dict[str, Any]:
        """Generic problem solver for unknown problem types"""
        data = problem.data
        
        # Attempt to infer problem type and provide generic solution
        if 'password' in data or 'username' in data:
            return self._solve_authentication(problem)
        elif 'validate' in str(data).lower():
            return self._solve_validation(problem)
        elif 'encrypt' in str(data).lower() or 'decrypt' in str(data).lower():
            return self._solve_encryption(problem)
        else:
            # Generic data processing
            return {
                'status': 'processed',
                'input_data': data,
                'processed_at': datetime.datetime.now().isoformat(),
                'message': 'Generic processing completed successfully'
            }
    
    def _calculate_confidence(self, problem: PPWProblem, solution_data: Dict[str, Any]) -> float:
        """Calculate confidence score for the solution"""
        confidence = 1.0
        
        # Reduce confidence if there are errors
        if 'error' in solution_data:
            confidence *= 0.1
        
        # Reduce confidence based on problem complexity
        complexity = len(problem.constraints) + len(problem.data)
        confidence *= max(0.3, 1.0 - (complexity * 0.05))
        
        # Increase confidence for known problem types
        if problem.type in [PPWProblemType.AUTHENTICATION, PPWProblemType.VALIDATION, PPWProblemType.ENCRYPTION]:
            confidence *= 1.2
        
        return min(1.0, confidence)
    
    def _update_performance_metrics(self, problem: PPWProblem, solution: PPWSolution):
        """Update performance tracking metrics"""
        metric = {
            'problem_type': problem.type.value,
            'execution_time': solution.execution_time,
            'confidence': solution.confidence,
            'timestamp': datetime.datetime.now().isoformat(),
            'success': 'error' not in solution.solution_data
        }
        
        self.performance_history.append(metric)
        
        # Keep only last 1000 metrics
        if len(self.performance_history) > 1000:
            self.performance_history = self.performance_history[-1000:]
    
    def _generate_security_recommendations(self, risk_level: str) -> List[str]:
        """Generate security recommendations based on risk level"""
        if risk_level == 'HIGH':
            return [
                'Enable multi-factor authentication',
                'Implement encryption for sensitive data',
                'Regular security audits required',
                'Restrict access permissions',
                'Monitor for suspicious activities'
            ]
        elif risk_level == 'MEDIUM':
            return [
                'Review access controls',
                'Update security policies',
                'Implement logging and monitoring'
            ]
        else:
            return [
                'Maintain current security measures',
                'Schedule periodic reviews'
            ]
    
    def get_performance_stats(self) -> Dict[str, Any]:
        """Get performance statistics"""
        if not self.performance_history:
            return {'message': 'No performance data available'}
        
        avg_execution_time = sum(m['execution_time'] for m in self.performance_history) / len(self.performance_history)
        avg_confidence = sum(m['confidence'] for m in self.performance_history) / len(self.performance_history)
        success_rate = sum(1 for m in self.performance_history if m['success']) / len(self.